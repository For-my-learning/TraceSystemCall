# TraceSystemCall
for learning linux kernel ,   system programmin, low level programming

```
fork() 後
親プロセス (child > 0)
┌─────────────┐
│ 親のメモリ  │
└─────────────┘

子プロセス (child == 0)
┌─────────────┐
│ 子のメモリ  │
│ tracer 子コード │
└─────────────┘
        │ execvp(argv[1], &argv[1]) 成功
        ▼
┌─────────────┐
│ 子のメモリ  │
│ 新しいプログラム │  ← 置き換わる
└─────────────┘

```

## exec 系は プロセス自体を別のプログラムで置き換える特殊関数

- 成功すると元のコードは「存在しないもの」となるので、exec 後のコードは実行されない

- 失敗した場合のみ、後ろのエラー処理コードに到達する


## execvp が置き換える「現在のプロセス」

- execvp は 呼び出したプロセス自身 を置き換える
  

- この場合、呼んでいるのは 子プロセス なので、置き換わるのは 子プロセスのメモリ空間

コード領域（text）

データ領域（data）

スタック

ヒープ


- 親プロセスのメモリは 影響を受けない


## fork() 呼び出し
```
[親プロセス] ← child = 子の PID (>0)
    → 子を監視する
[子プロセス] ← child = 0
    → 自分を親に監視させる

[親プロセス] (fork を呼んだ元)
PID  = 1000
PPID = 999
child = 1001  <-- fork が返した値（子の PID）

       │
       ▼
[子プロセス] (新しく作られたプロセス)
PID  = 1001
PPID = 1000  <-- 親の PID
fork の返り値 = 0
```


```
2. 動きのイメージ
fork() 呼び出し
      │
      ├── 子プロセス (child == 0) → if (child == 0) に到達
      │       ptrace → execvp → 実行
      │
      └── 親プロセス (child > 0) → else if (child > 0) に到達
              waitpid → ptrace → ループ


子プロセス側は if (child == 0) に入るだけ

親プロセス側は else if (child > 0) に入るだけ

両方のプロセスが同じコードを走っているが、分岐に応じて別々の処理
```

##  fork() の仕組み

 - fork() は 現在のプロセスのコピー を作る

- コピーされるもの：

- プログラムカウンタ（どの命令を実行しているか）

- スタック、ヒープの内容

- レジスタの状態

- これにより、親と子は同じコードからスタートする
```
fork() 呼び出し前
[プロセス] → コード全体を実行中

fork() 呼び出し後
[親プロセス] ← child > 0 → else if に進む
[子プロセス] ← child == 0 → if に進む
```

- fork() が返ると 親プロセスと子プロセスは同じ場所に戻る

- プログラムカウンタ（命令の位置）は fork() の次の命令を指している



